xlab(expression(sqrt(N) * (hat(beta)[1] - beta[1]))) +
ggtitle("Convergence of Beta Estimates (Lasso Regression)") +
scale_fill_manual(values = c("indianred1", "khaki", "springgreen3", "skyblue", "slateblue1", "darkorchid"))
# Plot for Random Forest with 1/sqrt(N) convergence rate
tib %>%
mutate(sqrtn_dev_rf = (1 / sqrt(as.numeric(as.character(N)))) * (betas1_rf - b1),
N_factor = as.factor(N)) %>%
ggplot(aes(x = sqrtn_dev_rf, y = fct_rev(N_factor), fill = N_factor)) +
geom_density_ridges() +
ylab("Sample Size N") +
xlab(expression(frac(1, sqrt(N)) * (hat(beta)[1] - beta[1]))) +
ggtitle("Convergence of Beta Estimates (Random Forest)") +
scale_fill_manual(values = c("indianred1", "khaki", "springgreen3", "skyblue", "slateblue1", "darkorchid"))
# Set seed for reproducibility
set.seed(1234)
### DGP 2
# log & exp scaled + piecewise function, only the first 7 covariates affect the outcome
dgp2 = function(n) {
X = matrix(rnorm(n * 10), ncol = 10)
U = rnorm(n)
# True coefficients (only the first 5 covariates affect the outcome)
beta_true = c(1, -2, 3, -1, 0.5, -0.7, 0, 0, 0, 0)  # First five covariates affect the outcome
# Non-linear terms (logarithmic, exponential, and piecewise)
X1_log = log(abs(X[, 1]) + 1)
X2_exp = exp(X[, 2]) / 10
X3_sin = sin(X[, 3])
X4_cos = cos(X[, 4])
X5_piecewise = ifelse(X[, 5] > 0, X[, 5]^2, X[, 5] * 2)
X6_piecewise = ifelse(X[, 6] < -1, -X[, 6], X[, 6]^3)
# Define the outcome Y based on the true coefficients and the non-linear transformations
Y = beta_true[1] * X1_log + beta_true[2] * X2_exp + beta_true[3] * X3_sin +
beta_true[4] * X4_cos + beta_true[5] * X5_piecewise + beta_true[6] * X6_piecewise + U
# Combine the covariates and the outcome into a data frame
data = data.frame(Y = Y, X1 = X[, 1], X2 = X[, 2], X3 = X[, 3], X4 = X[, 4],
X5 = X[, 5], X6 = X[, 6], X7 = X[, 7], X8 = X[, 8],
X9 = X[, 9], X10 = X[, 10])
return(data)
}
# Number of replications
r = 100
# True betas for the DGP
betas =  c(1, -2, 3, -1, 0.5, -0.7, 0, 0, 0, 0)
b1 = betas[1]  # True beta1 (the first non-zero beta)
# Initialize an empty tibble to store results
tib = tibble(N = integer(0), betas1_lasso = numeric(0), betas1_rf = numeric(0))
# Sample sizes
sample_sizes = c(10, 40, 160, 640, 1024, 2560)
for (n in sample_sizes) { # Outer loop over sample sizes
print(paste("Running sample size:", n))
for (j in 1:r) { # Inner loop over replications
### DGP
data = dgp2(n)
### Random Forest
X = data[, 2:(ncol(data))]  # Extract the independent variables as a data frame
Y = data$Y  # Extract the response variable
forest = regression_forest(X, Y)
beta1_hat_rf = predict(forest)$predictions
### Lasso
cv_lasso = glmnet(X, Y)
beta1_hat_lasso = coef(cv_lasso)[2]  # Extract the estimate for beta1 (the first predictor)
# Store results in tibble
tib = bind_rows(tib, tibble(N = n, betas1_lasso = beta1_hat_lasso, betas1_rf = beta1_hat_rf))
}
}
# Plot for Lasso Regression
tib %>%
mutate(sqrtn_dev_lm = sqrt(as.numeric(as.character(N))) * (betas1_lasso - b1),
N_factor = as.factor(N)) %>%
ggplot(aes(x = sqrtn_dev_lm, y = fct_rev(N_factor), fill = N_factor)) +
geom_density_ridges() +
ylab("Sample Size N") +
xlab(expression(sqrt(N) * (hat(beta)[1] - beta[1]))) +
ggtitle("Convergence of Beta Estimates (Lasso Regression)") +
scale_fill_manual(values = c("indianred1", "khaki", "springgreen3", "skyblue", "slateblue1", "darkorchid"))
# Plot for Random Forest with 1/sqrt(N) convergence rate
tib %>%
mutate(sqrtn_dev_rf = (1 / sqrt(as.numeric(as.character(N)))) * (betas1_rf - b1),
N_factor = as.factor(N)) %>%
ggplot(aes(x = sqrtn_dev_rf, y = fct_rev(N_factor), fill = N_factor)) +
geom_density_ridges() +
ylab("Sample Size N") +
xlab(expression(frac(1, sqrt(N)) * (hat(beta)[1] - beta[1]))) +
ggtitle("Convergence of Beta Estimates (Random Forest)") +
scale_fill_manual(values = c("indianred1", "khaki", "springgreen3", "skyblue", "slateblue1", "darkorchid"))
# Number of measurement time points
time_point_SIMULATE <- 5 # Nt
# Size of crossloading (indicating misfit)
model_TRUE_MISS_SIMULATE <- c(.3,.6)
# What models to specify and run: within time points/ between time points
type_TRUE_MISS_SIMULATE <- c("none","tt","tt1")
# Number of data samples to generate and run model fit on them
run_Samples_SIMULATE <- 10
#
library(mvtnorm)
library(matrixcalc)
library(lavaan)
setwd("~/PycharmProjects/dsem_modelfit/src")
# Get the directory of the current script
current_dir <- "~/PycharmProjects/dsem_modelfit/src/"
# Dynamically source files from the local directory
source(file.path("~/PycharmProjects/dsem_modelfit/src/lavaan_dsem_models_randomintercept.R"))
source(file.path("~/PycharmProjects/dsem_modelfit/src/gen_data_version03.R"))
# source(file.path(current_dir, "lavaan_dsem_models_comp1.R"))
# source(file.path(current_dir,  "lavaan_dsem_models_comp2.R"))
source(file.path("~/PycharmProjects/dsem_modelfit/src/gen_data_version04.R"))
# Number of cores for parallelisation
cores <- 1
# Number of people / time point?
person_size_SIMULATE <- c(91)
# Number of measurement time points
time_point_SIMULATE <- 5 # Nt
# Size of crossloading (indicating misfit)
model_TRUE_MISS_SIMULATE <- c(.3,.6)
# What models to specify and run: within time points/ between time points
type_TRUE_MISS_SIMULATE <- c("none","tt","tt1")
# Number of data samples to generate and run model fit on them
run_Samples_SIMULATE <- 10
# DSEM model params
phi0 <- diag(2)*.7+.3 # cov(eta)
mu0  <- c(0, 0)        # mean(eta)
ar0  <- c(.3, .3)      # ar(1) structure
ly00 <- .6
ly0  <- matrix(c(ly00, ly00, ly00, 0, 0, 0,
0, 0, 0, ly00, ly00, ly00), 6, 2, byrow = F) # factor loadings
td   <- diag(6)*(1 - ly00^2) # cond. var(y) -> res var
# Fit indices
fitnom <- c("npar","fmin","chisq","df","pvalue","baseline.chisq","baseline.df",
"baseline.pvalue","cfi","tli","nnfi","rfi","nfi","pnfi","ifi","rni",
"logl","unrestricted.logl","aic","bic","ntotal","bic2","rmsea","rmsea.ci.lower",
"rmsea.ci.upper","rmsea.ci.level","rmsea.pvalue","rmsea.close.h0","rmsea.notclose.pvalue",
"rmsea.notclose.h0","rmr","rmr_nomean","srmr","srmr_bentler","srmr_bentler_nomean",
"crmr","crmr_nomean","srmr_mplus","srmr_mplus_nomean","cn_05","cn_01","gfi",
"agfi","pgfi","mfi","ecvi")
# Parallelise cores ############################################################
# TODO: for core in cores
# temporary core=1 for 1 run
core <- 1
# Function to fit a single model, capture fit specific errors for later
# Input: data y0
# Output: model res1
fit_model <- function(y0){
res1 <- try(sem(dsem[[time_point]], data = y0, std.lv = TRUE), silent = TRUE)
if(!inherits(res1, "try-error")){ # if there is no try-error
if(res1@optim$converged == T){ # if model converged: save fit indices
fitmeasures(res1)
}
else
{ # if model did not converge: save NAs
rep(NA, 46)
}
}
else
{ # if there is a try-error: save NAs
rep(NA, 46)
}
}
for (person_size in person_size_SIMULATE) { # looping over persons
for (time_point in time_point_SIMULATE) { # looping over time points
if(time_point*6 < person_size){ # checking if N_t+p < Nt? Specification requirement
for(type_MISS in type_TRUE_MISS_SIMULATE){ # check each misfit type
# set core specific seed
set.seed(131212023 + core + person_size + time_point*1000 + as.numeric(as.factor(type_MISS))*10000)
#####################################################################
if(type_MISS == "none"){ # core <- 1
# there are no missspecifications
model_TRUE_MISS <- 0
# save in current directory
name_local_SIMULATE_Info <- paste(current_dir, as.character(person_size), as.character(time_point), as.character(type_MISS),
as.character(model_TRUE_MISS), core, "_version03_rand", sep = "_")
#######################################
# empty matrix for results
#######################################
#run_Samples_SIMULATE <- SAMPLING <- 1
# Initialize empty matrix that stores fit indices
fitm1 <- matrix(NA, run_Samples_SIMULATE, 46)
N <- person_size
Nt <- time_point
ly1  <- matrix(c(0, 0, 0, model_TRUE_MISS, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
#######################################
# Start looping over number of samplings
for (SAMPLING in 1:run_Samples_SIMULATE){ # SAMPLING <- 1
# Generate data
dat1 <- gendata01(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
# Check if data is positive definite
if(dat1[["is_positive_def"]] == T){
y0 <- dat1[["y0"]]
# Fit model and store fit indices of this model in previously defined matrix, the row indicating the number of sampling
fitm1[SAMPLING,] <- fit_model(y0)
}
} # end looping sampling
# Adjust column names of the fit indices matrix
colnames(fitm1) <- fitnom
# Save samples run
#saveRDS(fitm1, file = paste0(name_local_SIMULATE_Info,".RDS"))
write.csv(fitm1, paste0(name_local_SIMULATE_Info, ".csv"))
#####################################################################
#####################################################################
}
else
{ # type_MISS <- "tt1": between time points
for(model_TRUE_MISS in model_TRUE_MISS_SIMULATE){ # check each misfit type # model_TRUE_MISS <- .3
# save in current directory
name_local_SIMULATE_Info <- paste(current_dir, as.character(person_size), as.character(time_point), as.character(type_MISS),
as.character(model_TRUE_MISS), core, "_version03_rand", sep = "_")
#######################################
# empty matrix for results
#######################################
# Initialize empty matrix that stores fit indices
fitm1 <- matrix(NA, run_Samples_SIMULATE, 46)
N <- person_size
Nt <- time_point
if(type_MISS == "tt"){
ly1  <- matrix(c(0, 0, 0, model_TRUE_MISS, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
}
else
{ # model_TRUE_MISS <- .3
ly1  <- matrix(c(model_TRUE_MISS, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
}
#######################################
# Start looping over number of samplings
for (SAMPLING in 1:run_Samples_SIMULATE){ # SAMPLING <-1
# Generate data
if(type_MISS == "tt"){
dat1 <- gendata01(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
}
else
{
dat1 <- gendata02(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
}
# Check if data is positive definite
if(dat1[["is_positive_def"]] == T){
y0 <- dat1[["y0"]]
# Fit model and store fit indices of this model in previously defined matrix, the row indicating the number of sampling
fitm1[SAMPLING,] <- fit_model(y0)
}
} # end looping sampling
# Adjust column names of the fit indices matrix
colnames(fitm1) <- fitnom
# Save samples run
write.csv(fitm1, paste0(name_local_SIMULATE_Info, ".csv"))
#saveRDS(fitm1, file = paste0(name_local_SIMULATE_Info,".RDS"))
} # end looping over misfit types
} # end else
} # end looping over misfit types
} # end checking specification requirement
} # end looping over time points
} # end looping over persons
person_size_SIMULATE <- c(91,121, 151, 181,211,61,31,501,1001,1501,2001,2501) #
time_point_SIMULATE <- c(1:5,10,15,30) # Nt ,30
model_TRUE_MISS_SIMULATE <- c(0,.3,.6)
type_TRUE_MISS_SIMULATE <- c("tt","tt1") # within time points, between time points #"none", HB: taken out because true tt/tt1 model used for type I error rates
run_Samples_SIMULATE <- 125
runpcs <- 2
# FIT INDICES WE ARE ACTUALLY INTERESTED IN
fitnom <- c("cfi","tli","rmsea","srmr","gfi","agfi","cgfi")
cond0 <- data.frame(matrix(NA,1000,4))
res3false <- res3true <- data.frame(matrix(NA,1000,length(fitnom)+2))
res4false <- res4true <- data.frame(matrix(NA,1000,length(fitnom)+2))
# output names
fitnom.res1 <- c("npar","fmin","chisq","df","pvalue","baseline.chisq","baseline.df",
"baseline.pvalue","cfi","tli","nnfi","rfi","nfi","pnfi","ifi","rni",
"logl","unrestricted.logl","aic","bic","ntotal","bic2","rmsea","rmsea.ci.lower",
"rmsea.ci.upper","rmsea.ci.level","rmsea.pvalue","rmsea.close.h0","rmsea.notclose.pvalue",
"rmsea.notclose.h0","rmr","rmr_nomean","srmr","srmr_bentler","srmr_bentler_nomean",
"crmr","crmr_nomean","srmr_mplus","srmr_mplus_nomean","cn_05","cn_01","gfi",
"agfi","pgfi","mfi","ecvi")
getstuff <- function(name_local_SIMULATE_Info){
res11 <- try(readRDS(file = name_local_SIMULATE_Info), silent = TRUE)
if(!inherits(res11, "try-error")){
res11
}else{
matrix(NA,run_Samples_SIMULATE,length(fitnom.res1))
}
}
ijk <- 1
for (time_point in time_point_SIMULATE) {
for (person_size in person_size_SIMULATE) {
for(type_MISS in type_TRUE_MISS_SIMULATE){
for (model_TRUE_MISS in model_TRUE_MISS_SIMULATE){
N <- person_size#<-211  # persons
Nt <- time_point#<-2 #time points
if(time_point*6<person_size){
res1 <- res2 <- data.frame(matrix(NA,1,length(fitnom.res1)))
colnames(res1) <- colnames(res2) <- fitnom.res1
for(i in 1:runpcs){
# MISSSPECIFICATIONS
name_local_SIMULATE_Info <- paste("C:\\holger\\SEM\\modelfit\\stanversion\\results_lavaan_version03_rand\\local", as.character(person_size),
as.character(time_point),as.character(type_MISS),as.character(model_TRUE_MISS),i ,"_version03_rand.RDS", sep = "_")
# TRUE DGP
name_local_SIMULATE_Info2 <- paste("C:\\holger\\SEM\\modelfit\\stanversion\\results_lavaan_version03_rand\\local", as.character(person_size),
as.character(time_point),as.character(type_MISS),as.character(model_TRUE_MISS),i ,"_version03_rand_true.RDS", sep = "_")
res11 <- getstuff(name_local_SIMULATE_Info)
res21 <- getstuff(name_local_SIMULATE_Info2)
colnames(res21) <- colnames(res11) <- fitnom.res1
res1 <- rbind(res1,res11)
res2 <- rbind(res2,res21)
}
#colnames(res11) <- colnames(res1m2) <- colnames(res1m2) <- colnames(res0)
#colnames(res1m12) <- colnames(res1m13) <- c("chi2","chi2_p")
res1 <- data.frame(res1[-1,])
res2 <- data.frame(res2[-1,])
res1$cgfi <- res1$gfi+(Nt*6+1)*Nt*6/res1$npar/N
res2$cgfi <- res2$gfi+(Nt*6+1)*Nt*6/res2$npar/N
#dim(res1)
# average scores m false (except none)
# FIT INDICES FOR WRONG MODEL
# AVERAGE SCORES
res3false[ijk,1] <- mean(res1$chisq/res1$df,na.rm=T) # CHI2
res3false[ijk,1:length(fitnom)+1] <- apply(res1[fitnom],2,mean,na.rm=T)
res3false[ijk,length(fitnom)+2] <- length(na.omit(res1$npar)) # LENGHT OF MISSING DATA
# average scores m true
# FIT INDICES FOR TRUE MODEL
res3true[ijk,1] <- mean(res2$chisq/res1$df,na.rm=T)
res3true[ijk,1:length(fitnom)+1] <- apply(res2[fitnom],2,mean,na.rm=T)
res3true[ijk,length(fitnom)+2] <- length(na.omit(res2$npar))
# CUT OFFS
#cutoffs good fit (misfit): percentage of rejection
res4false[ijk,1] <- 1-mean(res1$pvalue>.05,na.rm=T) # if p-value is larger than 5% then its 1 = percentage of rejection = POWER
res4false[ijk,2] <- 1-mean(res1$chisq < 2*res1$df,na.rm=T)
res4false[ijk,3] <- 1-mean(res1$cfi > .95,na.rm=T)
res4false[ijk,4] <- 1-mean(res1$tli > .97,na.rm=T)
res4false[ijk,5] <- 1-mean(res1$rmsea < .05,na.rm=T)
res4false[ijk,6] <- 1-mean(res1$srmr < .05,na.rm=T)
res4false[ijk,7] <- 1-mean(res1$gfi > .95,na.rm=T)
res4false[ijk,8] <- 1-mean(res1$agfi > .95,na.rm=T)
res4false[ijk,9] <- 1-mean(res1$cgfi > .95,na.rm=T)
res4true[ijk,1] <- 1-mean(res2$pvalue>.05,na.rm=T) # TYPE 1 ERROR RATES
res4true[ijk,2] <- 1-mean(res2$chisq < 2*res1$df,na.rm=T)
res4true[ijk,3] <- 1-mean(res2$cfi > .95,na.rm=T)
res4true[ijk,4] <- 1-mean(res2$tli > .97,na.rm=T)
res4true[ijk,5] <- 1-mean(res2$rmsea < .05,na.rm=T)
res4true[ijk,6] <- 1-mean(res2$srmr < .05,na.rm=T)
res4true[ijk,7] <- 1-mean(res2$gfi > .95,na.rm=T)
res4true[ijk,8] <- 1-mean(res2$agfi > .95,na.rm=T)
res4true[ijk,9] <- 1-mean(res2$cgfi > .95,na.rm=T)
# good fit is enough:
#cutoffs acceptable fit
#res4[ijk,1] <- 1-mean(res1$pvalue>.05,na.rm=T)
#res4[ijk,2] <- 1-mean(res1$chisq < 3*res1$df,na.rm=T)
#res4[ijk,3] <- 1-mean(res1$cfi > .90,na.rm=T)
#res4[ijk,4] <- 1-mean(res1$tli > .95,na.rm=T)
#res4[ijk,5] <- 1-mean(res1$rmsea < .08,na.rm=T)
#res4[ijk,6] <- 1-mean(res1$srmr < .08,na.rm=T)
cond0[ijk,] <- c(time_point,person_size,type_MISS,model_TRUE_MISS)
ijk <- ijk+1 # adding a new line
}
}
}
}
}
current_dir <- "~/PycharmProjects/dsem_modelfit/src/"
#
library(mvtnorm)
library(matrixcalc)
library(lavaan)
setwd("~/PycharmProjects/dsem_modelfit/src")
# Get the directory of the current script
current_dir <- "~/PycharmProjects/dsem_modelfit/src/"
# Dynamically source files from the local directory
source(file.path("~/PycharmProjects/dsem_modelfit/src/lavaan_dsem_models_randomintercept.R"))
source(file.path("~/PycharmProjects/dsem_modelfit/src/gen_data_version03.R"))
# source(file.path(current_dir, "lavaan_dsem_models_comp1.R"))
# source(file.path(current_dir,  "lavaan_dsem_models_comp2.R"))
source(file.path("~/PycharmProjects/dsem_modelfit/src/gen_data_version04.R"))
# Number of cores for parallelisation
cores <- 1
# Number of people / time point?
person_size_SIMULATE <- c(91)
# Number of measurement time points
time_point_SIMULATE <- 5 # Nt
# Size of crossloading (indicating misfit)
model_TRUE_MISS_SIMULATE <- c(.3,.6)
# What models to specify and run: within time points/ between time points
type_TRUE_MISS_SIMULATE <- c("none","tt","tt1")
# Number of data samples to generate and run model fit on them
run_Samples_SIMULATE <- 10
# DSEM model params
phi0 <- diag(2)*.7+.3  # cov(eta)
mu0  <- c(0, 0)        # mean(eta)
ar0  <- c(.3, .3)      # ar(1) structure
ly00 <- .6
ly0  <- matrix(c(ly00, ly00, ly00, 0, 0, 0,
0, 0, 0, ly00, ly00, ly00), 6, 2, byrow = F) # factor loadings
td   <- diag(6)*(1 - ly00^2) # cond. var(y) -> res var
# Fit indices
fitnom <- c("npar","fmin","chisq","df","pvalue","baseline.chisq","baseline.df",
"baseline.pvalue","cfi","tli","nnfi","rfi","nfi","pnfi","ifi","rni",
"logl","unrestricted.logl","aic","bic","ntotal","bic2","rmsea","rmsea.ci.lower",
"rmsea.ci.upper","rmsea.ci.level","rmsea.pvalue","rmsea.close.h0","rmsea.notclose.pvalue",
"rmsea.notclose.h0","rmr","rmr_nomean","srmr","srmr_bentler","srmr_bentler_nomean",
"crmr","crmr_nomean","srmr_mplus","srmr_mplus_nomean","cn_05","cn_01","gfi",
"agfi","pgfi","mfi","ecvi")
# Parallelise cores ############################################################
# TODO: for core in cores
# temporary core=1 for 1 run
core <- 1
# Function to fit a single model, capture fit specific errors for later
# Input: data y0
# Output: model res1
fit_model <- function(y0){
res1 <- try(sem(dsem[[time_point]], data = y0, std.lv = TRUE), silent = TRUE)
if(!inherits(res1, "try-error")){ # if there is no try-error
if(res1@optim$converged == T){ # if model converged: save fit indices
fitmeasures(res1)
}
else
{ # if model did not converge: save NAs
rep(NA, 46)
}
}
else
{ # if there is a try-error: save NAs
rep(NA, 46)
}
}
for (person_size in person_size_SIMULATE) { # looping over persons
for (time_point in time_point_SIMULATE) { # looping over time points
if(time_point*6 < person_size){ # checking if N_t+p < Nt? Specification requirement
for(type_MISS in type_TRUE_MISS_SIMULATE){ # check each misfit type
# set core specific seed
set.seed(131212023 + core + person_size + time_point*1000 + as.numeric(as.factor(type_MISS))*10000)
#####################################################################
if(type_MISS == "none"){ # core <- 1
# there are no missspecifications
model_TRUE_MISS <- 0
# save in current directory
name_local_SIMULATE_Info <- paste(current_dir, as.character(person_size), as.character(time_point), as.character(type_MISS),
as.character(model_TRUE_MISS), core, "_version03_rand", sep = "_")
#######################################
# empty matrix for results
#######################################
#run_Samples_SIMULATE <- SAMPLING <- 1
# Initialize empty matrix that stores fit indices
fitm1 <- matrix(NA, run_Samples_SIMULATE, 46)
N <- person_size
Nt <- time_point
ly1  <- matrix(c(0, 0, 0, model_TRUE_MISS, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
#######################################
# Start looping over number of samplings
for (SAMPLING in 1:run_Samples_SIMULATE){ # SAMPLING <- 1
# Generate data
dat1 <- gendata01(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
# Check if data is positive definite
if(dat1[["is_positive_def"]] == T){
y0 <- dat1[["y0"]]
# Fit model and store fit indices of this model in previously defined matrix, the row indicating the number of sampling
fitm1[SAMPLING,] <- fit_model(y0)
}
} # end looping sampling
# Adjust column names of the fit indices matrix
colnames(fitm1) <- fitnom
# Save samples run
#saveRDS(fitm1, file = paste0(name_local_SIMULATE_Info,".RDS"))
write.csv(fitm1, paste0(name_local_SIMULATE_Info, ".csv"))
#####################################################################
#####################################################################
}
else
{ # type_MISS <- "tt1": between time points
for(model_TRUE_MISS in model_TRUE_MISS_SIMULATE){ # check each misfit type # model_TRUE_MISS <- .3
# save in current directory
name_local_SIMULATE_Info <- paste(current_dir, as.character(person_size), as.character(time_point), as.character(type_MISS),
as.character(model_TRUE_MISS), core, "_version03_rand", sep = "_")
#######################################
# empty matrix for results
#######################################
# Initialize empty matrix that stores fit indices
fitm1 <- matrix(NA, run_Samples_SIMULATE, 46)
N <- person_size
Nt <- time_point
if(type_MISS == "tt"){
ly1  <- matrix(c(0, 0, 0, model_TRUE_MISS, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
}
else
{ # model_TRUE_MISS <- .3
ly1  <- matrix(c(model_TRUE_MISS, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0), 6, 2, byrow = F) # factor loadings
}
#######################################
# Start looping over number of samplings
for (SAMPLING in 1:run_Samples_SIMULATE){ # SAMPLING <-1
# Generate data
if(type_MISS == "tt"){
dat1 <- gendata01(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
}
else
{
dat1 <- gendata02(N, Nt, phi0, mu0, ar0, ly0, ly1, td)
}
# Check if data is positive definite
if(dat1[["is_positive_def"]] == T){
y0 <- dat1[["y0"]]
# Fit model and store fit indices of this model in previously defined matrix, the row indicating the number of sampling
fitm1[SAMPLING,] <- fit_model(y0)
}
} # end looping sampling
# Adjust column names of the fit indices matrix
colnames(fitm1) <- fitnom
# Save samples run
write.csv(fitm1, paste0(name_local_SIMULATE_Info, ".csv"))
#saveRDS(fitm1, file = paste0(name_local_SIMULATE_Info,".RDS"))
} # end looping over misfit types
} # end else
} # end looping over misfit types
} # end checking specification requirement
} # end looping over time points
} # end looping over persons
